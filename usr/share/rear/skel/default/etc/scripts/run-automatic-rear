#!/bin/bash

source /etc/scripts/system-setup-functions.sh

# Make it explicit that the 'recover' workflow is always verbose (cf. usr/sbin/rear)
# so when a 'rear $rear_options recover' command is shown to the user it contains '-v':
rear_options='-v'
# In debug mode run an automated 'rear $rear_options recover' command in debugscript mode.
# Because the kernel command line option 'debug' means 'set -x' for the system setup scripts
# it should also mean '-D' (i.e. 'set -x') for an automated 'rear $rear_options recover' run:
rear_debug && rear_options='-D'
# In unattended_recovery mode run an automated 'rear $rear_options recover' in non-interactive mode:
unattended_recovery && rear_options+=' --non-interactive'

# In automatic_recovery mode call RECOVERY_COMMANDS automatically
# but without automated calling REBOOT_COMMANDS after successful recovery:
if automatic_recovery ; then
    choices=( "View Relax-and-Recover log file(s)"
              "Login at the rescue system"
            )
    echo "Launching '$RECOVERY_COMMANDS_LABEL' automatically"
    for command in "${RECOVERY_COMMANDS[@]}" ; do
        rear_debug && echo "Running RECOVERY_COMMANDS '$command'"
        eval "$command"
        recovery_command_exit_code=$?
        test $recovery_command_exit_code -eq 0 || echo "'eval $command' results exit code $recovery_command_exit_code"
    done
    if test $recovery_command_exit_code -eq 0 ; then
        echo "'$RECOVERY_COMMANDS_LABEL' finished successfully"
        choices+=( "$REBOOT_COMMANDS_LABEL" )
    else
        echo "'$RECOVERY_COMMANDS_LABEL' failed with exit code $recovery_command_exit_code"
    fi
    PS3="Select what to do "
    select choice in "${choices[@]}" ; do
        case "$REPLY" in
            (1)
                # Do not assume the ReaR log file is named rear-$HOSTNAME.log
                # the user can have specified any name as LOGFILE:
                less /var/log/rear/*
                ;;
            (2)
                echo "" > /etc/issue
                echo "" > /etc/motd
                break
                ;;
            (3)
                for command in "${REBOOT_COMMANDS[@]}" ; do
                    rear_debug && echo "Running REBOOT_COMMANDS '$command'"
                    eval "$command" || echo "'eval $command' results exit code $?"
                done
                # Wait hardcoded 10 seconds to not let this script "just proceed"
                # because it would proceed with an iteration of the 'select' loop
                # which is not wanted for the normal reboot/poweroff cases
                # so we sleep 10 seconds to give reboot/poweroff some time
                # to terminate this script while it is idle waiting here
                # but in exceptional cases (when REBOOT_COMMANDS did not reboot/poweroff)
                # it proceeds after 10 seconds with an iteration of the 'select' loop:
                sleep 10
                ;;
        esac
        for (( i=1 ; i <= ${#choices[@]} ; i++ )) ; do
            echo "$i) ${choices[$i-1]}"
        done
    done 2>&1
fi

# In unattended_recovery mode call RECOVERY_COMMANDS automatically
# plus automated calling REBOOT_COMMANDS after successful recovery:
if unattended_recovery ; then
    choices=( "View Relax-and-Recover log file(s)"
              "Login at the rescue system"
            )
    echo "Launching '$RECOVERY_COMMANDS_LABEL' automatically"
    for command in "${RECOVERY_COMMANDS[@]}" ; do
        rear_debug && echo "Running RECOVERY_COMMANDS '$command'"
        eval "$command"
        recovery_command_exit_code=$?
        test $recovery_command_exit_code -eq 0 || echo "'eval $command' results exit code $recovery_command_exit_code"
    done
    if test $recovery_command_exit_code -eq 0 ; then
        echo "'$RECOVERY_COMMANDS_LABEL' finished successfully"
        echo "'$REBOOT_COMMANDS_LABEL' in $USER_INPUT_INTERRUPT_TIMEOUT seconds (Ctrl-C to interrupt)"
        sleep $USER_INPUT_INTERRUPT_TIMEOUT
        for command in "${REBOOT_COMMANDS[@]}" ; do
            rear_debug && echo "Running REBOOT_COMMANDS '$command'"
            eval "$command" || echo "'eval $command' results exit code $?"
        done
        # Wait hardcoded 10 seconds to not let this script "just proceed"
        # because it would show the login screen when this script finished
        # which is not wanted for the normal reboot/poweroff cases
        # so we sleep 10 seconds to give reboot/poweroff some time
        # to terminate this script while it is idle waiting here
        # but in exceptional cases (when REBOOT_COMMANDS did not reboot/poweroff)
        # it proceeds after 10 seconds with the login screen:
        sleep 10
    else
        echo "'$RECOVERY_COMMANDS_LABEL' failed with exit code $recovery_command_exit_code"
        PS3="Select what to do "
        select choice in "${choices[@]}" ; do
            case "$REPLY" in
                (1)
                    # Do not assume the ReaR log file is named rear-$HOSTNAME.log
                    # the user can have specified any name as LOGFILE:
                    less /var/log/rear/*
                    ;;
                (2)
                    echo "" > /etc/issue
                    echo "" > /etc/motd
                    break
                    ;;
            esac
            for (( i=1 ; i <= ${#choices[@]} ; i++ )) ; do
                echo "$i) ${choices[$i-1]}"
            done
        done 2>&1
    fi
fi
